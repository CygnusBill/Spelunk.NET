# MCP Roslyn Tools Synopsis

## Overview

The MCP Roslyn Server provides a comprehensive set of tools for multi-language code analysis, navigation, and manipulation at various granularities. These tools are designed to be composable, allowing agents to perform complex refactoring operations through coordinated use of multiple tools.

## Supported Languages

- **C#** - Full support via Roslyn compiler services
- **VB.NET** - Full support via Roslyn compiler services with language-agnostic mapping
- **F#** - Basic support via FSharp.Compiler.Service (separate from Roslyn)

### Language-Agnostic Features
The server provides unified abstractions across supported languages:
- C# `void` methods ‚Üî VB.NET `Sub` procedures
- C# `static` ‚Üî VB.NET `Shared`
- C# `abstract` ‚Üî VB.NET `MustInherit`
- C# `virtual` ‚Üî VB.NET `Overridable`
- C# `override` ‚Üî VB.NET `Overrides`

## Format Conventions

### Location Format
Many tools accept or return location objects:
```json
{
  "file": "/absolute/path/to/file.cs",
  "line": 42,      // 1-based line number
  "column": 9      // 1-based column number
}
```

### RoslynPath Format (New - More Stable)
RoslynPath provides stable code references that survive edits:
```json
{
  "roslynPath": "//class[UserService]/method[GetUser]/block/statement[1]",
  "file": "/absolute/path/to/file.cs"
}
```

**Common RoslynPath Patterns:**
- `//method[ProcessOrder]` - Find method named ProcessOrder
- `//method[@async]` - Find all async methods
- `//statement[@contains='Console.WriteLine']` - Find console output
- `//statement[@type=IfStatement and @contains='null']` - Find null checks
- See [ROSLYN_PATH_INSTRUCTIONS.md](./ROSLYN_PATH_INSTRUCTIONS.md) for full syntax

### Pattern Syntax
- **Wildcards**: `*` (multiple chars), `?` (single char)
  - Examples: `*Controller`, `Get*`, `Is?Valid`
- **Regex**: When `patternType: "regex"` is specified
  - Uses .NET regex syntax
  - Examples: `"async.*{"`, `"(?<!await ).*Async\\("`

### Statement IDs
- Format: `stmt-123` (ephemeral, session-scoped)
- Generated by `find-statements` tool
- Valid only within current session
- Can be used with `replace-statement` for convenient statement targeting
- Stored in session memory with full syntax node references

### Marker IDs
- Format: `mark-1`, `mark-2`, etc.
- Generated by `mark-statement` tool
- Survive through code edits but not file reloads
- Built on Roslyn's SyntaxAnnotation system for reliable node tracking

## Choosing the Right Tool

The server offers two complementary approaches for code analysis:

### Semantic Tools (find-* family)
Use these when you need:
- Type information and symbol resolution
- Cross-file analysis (implementations, overrides, references)
- Rich metadata (fully qualified names, project context)
- Simple, task-focused queries
- Information about inheritance and interfaces

**Best for**: "Find all implementations of IDisposable", "Find methods that override BaseMethod", "Find all references to this property"

### Syntactic Tools (RoslynPath-based)
Use these when you need:
- Complex structural patterns
- Expression-level queries
- Code style analysis
- Performance (no compilation required)
- Queries on potentially broken code

**Best for**: "Find all null comparisons in if statements", "Find methods with more than 10 parameters", "Find all TODO comments in catch blocks"

### Quick Decision Guide
- **Finding a specific method by name?** ‚Üí Use `find-method`
- **Finding methods with specific patterns?** ‚Üí Use `query-syntax` with RoslynPath
- **Need type information?** ‚Üí Use semantic tools
- **Need AST navigation?** ‚Üí Use syntactic tools
- **Simple query?** ‚Üí Start with find-* tools
- **Complex query?** ‚Üí Use RoslynPath

## Tool Categories

### 1. Workspace Management

#### `spelunk-load-workspace`
**MCP Description**: "Load a .NET solution or project into the workspace"

**Purpose**: Load a C# project or solution into the workspace for analysis and manipulation.

**‚ö†Ô∏è Important**: Only full (absolute) paths are supported. Relative paths like `./project.csproj` or `../solution.sln` will not work because the server needs to resolve project references and dependencies correctly.

**Input Format**:
```json
{
  "path": "/path/to/project.csproj",  // Required: FULL PATH to .sln or .csproj file (relative paths not supported)
  "workspaceId": "custom-id"          // Optional: auto-generated if not provided
}
```

**Output Format**:
```json
{
  "Id": "TestProject_1b72f2d7",
  "Path": "/path/to/project.csproj",
  "Type": "Project",
  "Status": "Loaded",
  "LoadedAt": "2025-07-29T23:28:01Z",
  "ProjectCount": 1
}
```

**Use Case**: Must be called before any other operations to establish the working context

#### `spelunk-workspace-status`
**MCP Description**: "Get loading progress and workspace info"

**Purpose**: Get detailed status of loaded workspaces including project information.

**Input Format**:
```json
{
  "workspaceId": "specific-id"  // Optional: returns all if not specified
}
```

**Output Format**:
```json
{
  "workspaceCount": 1,
  "totalProjectCount": 3,
  "workspaces": [
    {
      "id": "TestProject_1b72f2d7",
      "path": "/path/to/project.csproj",
      "type": "Project",
      "status": "Loaded",
      "loadedAt": "2025-07-29T23:28:01Z",
      "projectCount": 3,
      "projects": ["Project1", "Project2", "Project3"]
    }
  ]
}
```

**Use Case**: Check what projects are available for analysis, verify load status

#### `spelunk-fsharp-projects`
**MCP Description**: "Get information about F# projects in the workspace (detected but not loaded by MSBuild)"

**Purpose**: List F# projects that were detected but cannot be loaded by MSBuildWorkspace due to F# compiler limitations.

**Input Format**:
```json
{
  "workspaceId": "specific-id",  // Optional: filter by workspace
  "includeLoaded": false         // Optional: include successfully loaded F# projects
}
```

**Output Format**:
```text
F# Projects (Skipped): 2

Project: FSharpLibrary
  Path: /path/to/FSharpLibrary.fsproj
  Workspace: MyProject_a1b2c3d4
  Status: Not Loaded
  Detected: 2025-01-15 10:30:25

Note: F# projects are not fully supported by MSBuildWorkspace.
To work with F# projects, use FSharp.Compiler.Service directly.
```

**Use Case**: Identify F# projects in mixed-language solutions, understand why certain projects aren't loaded

#### `spelunk-get-diagnostics`
**MCP Description**: "Get compilation diagnostics (errors, warnings, info) from the workspace"

**Purpose**: Retrieve compilation errors, warnings, and info messages with precise locations for error resolution.

**Input Format**:
```json
{
  "workspaceId": "TestProject_1b72f2d7",  // Optional: filter by workspace
  "severityFilter": "Error",              // Optional: Error|Warning|Info|Hidden
  "file": "/path/to/file.cs",            // Optional: filter by specific file
  "maxResults": 100                       // Optional: limit results (default: 50)
}
```

**Output Format**:
```json
{
  "diagnostics": [
    {
      "id": "CS0103",
      "severity": "Error", 
      "message": "The name 'undeclaredVariable' does not exist in the current context",
      "location": {
        "file": "/path/test-workspace/Program.cs",
        "line": 14,
        "column": 9
      },
      "category": "Compiler",
      "warningLevel": 0,
      "isEnabledByDefault": true,
      "isSuppressed": false
    }
  ],
  "summary": {
    "totalCount": 4,
    "errorCount": 4,
    "warningCount": 0,
    "infoCount": 0
  }
}
```

**Common Diagnostic IDs**:
- **CS0103**: Undeclared variable/method
- **CS1061**: Missing method on type
- **CS0029**: Type conversion error
- **CS0246**: Missing type/namespace
- **CS0161**: Not all code paths return
- **CS8618**: Non-nullable reference not initialized

**Use Case**: Starting point for diagnostic-driven error resolution, identifying compilation issues before refactoring

#### `spelunk-load-fsharp-project`
**MCP Description**: "Load an F# project using FSharp.Compiler.Service (separate from MSBuild workspaces)"

**Purpose**: Load and analyze F# projects using the F# compiler service directly.

**Input Format**:
```json
{
  "projectPath": "/path/to/project.fsproj"  // Required: path to F# project file
}
```

**Output Format**:
```text
F# Project: FSharpLibrary
Path: /path/to/FSharpLibrary.fsproj
Status: Loaded successfully
Source Files: 5
  - Library.fs
  - Types.fs
  - AsyncExamples.fs
  - PatternMatching.fs
  - Utils.fs
References: 8
```

**Use Case**: Enable F# code analysis when MSBuildWorkspace cannot handle F# projects

#### `spelunk-fsharp-find-symbols`
**MCP Description**: "Find symbols in F# code using pattern matching"

**Purpose**: Find F# symbols (functions, values, types) using pattern matching.

**Input Format**:
```json
{
  "filePath": "/path/to/file.fs",          // Required: F# source file
  "query": "*"                             // Required: pattern (* and ? wildcards)
}
```

**Pattern Examples**:
- `*` - All symbols
- `add*` - Symbols starting with 'add'
- `*Test` - Symbols ending with 'Test'
- `factorial` - Exact match
- `get?ser` - Single character wildcard

**Output Format**:
```text
Found 67 F# symbols matching '*'

Symbol: factorial
  Type: Function
  File: Library.fs
  Access: public
  - Recursive

Symbol: quickSort
  Type: Function
  File: Algorithms.fs
  Access: public
  - Recursive
```

**Use Case**: Navigate and analyze F# code structures, find specific F# constructs

#### `spelunk-fsharp-query`
**MCP Description**: "Query F# AST using FSharpPath expressions"

**Purpose**: Execute complex FSharpPath queries against F# abstract syntax trees.

**Input Format**:
```json
{
  "file": "/path/to/file.fs",              // Required: F# source file
  "fsharpPath": "//let[@name='factorial']", // Required: FSharpPath query
  "includeContext": true,                   // Optional: include source context
  "contextLines": 2                         // Optional: lines of context
}
```

**FSharpPath Examples**:
- `//let` - All let bindings
- `//let[@name='factorial']` - Specific function by name
- `//function` - All functions (with parameters)
- `//value` - All values (no parameters)
- `//type` - All type definitions
- `//module` - All modules
- `//match` - All pattern matches
- `//*[@name]` - All named nodes

**Output Format**:
```text
Found 1 match for FSharpPath: //let[@name='factorial']

[1] Binding: factorial
    Type: let binding
    Location: /path/to/Math.fs:15:8
    
    Context:
    14:     // Recursive factorial function
    15:     let rec factorial n =
    16:         match n with
    17:         | 0 | 1 -> 1
```

**Use Case**: Perform complex structural searches on F# code

#### `spelunk-fsharp-get-ast`
**MCP Description**: "Get AST structure for F# code"

**Purpose**: Retrieve and visualize F# abstract syntax tree structure.

**Input Format**:
```json
{
  "filePath": "/path/to/file.fs",          // Required: F# source file
  "root": "//module[MathOperations]",      // Optional: FSharpPath to root node
  "depth": 3,                              // Optional: tree depth (default: 3)
  "includeRange": true                     // Optional: include position info
}
```

**Output Format**:
```text
# F# AST Structure

File: /path/to/Math.fs
Root: //module[MathOperations]
Depth: 3

Module [MathOperations] @ 3:0
  NestedModule [MathOperations] @ 3:7
    Let [add] @ 5:8
      Function @ 5:8
        Parameters: x, y
    Let [factorial] @ 15:8
      Function @ 15:12 (recursive)
        Match @ 16:8
          Pattern: 0 | 1
          Pattern: _
```

**Use Case**: Understand F# code structure, debug FSharpPath queries

### 2. Code Discovery Tools (Read-Only)

#### `spelunk-find-class`
**MCP Description**: "Find classes, interfaces, structs, or enums by name pattern (supports * and ? wildcards)"

**Purpose**: Find type definitions by name pattern using wildcards.

**Input Format**:
```json
{
  "pattern": "*Controller",           // Required: supports * and ? wildcards
  "workspacePath": "/path/to/search"  // Optional: searches all if not specified
}
```

**Output Format**:
```text
Found 3 type(s) matching '*Controller':

1. UserController (class)
   Location: /path/src/UserController.cs:5:1
   Namespace: MyApp.Controllers
   Base: ControllerBase
   Implements: IUserService

2. ProductController (class)
   Location: /path/src/ProductController.cs:8:1
   Namespace: MyApp.Controllers
```

**Pattern Examples**:
- `*Controller` - All controllers
- `I*Service` - All service interfaces
- `Base*` - All base classes
- `User?` - User1, UserA, etc.

**Use Case**: Discover classes matching naming conventions, find all implementations of a pattern

#### `spelunk-find-method`
**MCP Description**: "Find methods by name pattern with optional class pattern filter (supports * and ? wildcards)"

**Purpose**: Find methods by name pattern with optional class filtering.

**Input Format**:
```json
{
  "methodPattern": "Get*",             // Required: method name pattern
  "classPattern": "*Service",         // Optional: filter by class pattern
  "workspacePath": "/path/to/search"  // Optional: searches all if not specified
}
```

**Output Format**:
```text
Found 5 method(s) matching 'Get*':

1. GetUser in UserService
   Location: /path/src/UserService.cs:15:5
   Signature: public Task<User> GetUser(int id)
   Returns: Task<User>
   Parameters: int id

2. GetAllUsers in UserService
   Location: /path/src/UserService.cs:25:5
   Signature: public Task<List<User>> GetAllUsers()
```

**Use Case**: Locate methods for analysis, find all async methods, discover API endpoints

#### `spelunk-find-property`
**MCP Description**: "Find properties and fields by name pattern with optional class pattern filter (supports * and ? wildcards)"

**Purpose**: Find properties and fields by name pattern.

**Input Format**:
```json
{
  "propertyPattern": "Is*",            // Required: property/field name pattern
  "classPattern": "*Model",           // Optional: filter by class pattern
  "workspacePath": "/path/to/search"  // Optional: searches all if not specified
}
```

**Output Format**:
```text
Found 4 properties/fields matching 'Is*':

1. IsActive (property) in UserModel
   Location: /path/src/Models/UserModel.cs:10:5
   Type: bool
   Getter: public
   Setter: public

2. IsDeleted (field) in BaseEntity
   Location: /path/src/Models/BaseEntity.cs:5:5
   Type: bool
   Access: private
```

**Use Case**: Find all boolean flags, discover model properties, locate configuration fields

#### `spelunk-find-namespace`
**Note**: This tool is not currently implemented in the server.

**Purpose**: Find namespaces by pattern.
- **Input**: Name pattern
- **Output**: List of namespaces with member counts
- **Use Case**: Understand code organization

### 3. Relationship Analysis Tools

#### üîç Inheritance Hierarchy Navigation
McpDotnet provides comprehensive tools for tracing inheritance chains and understanding type relationships:

- **`spelunk-find-implementations`** - Find all classes implementing an interface or abstract class
- **`spelunk-find-derived-types`** - Find all classes inheriting from a base class  
- **`spelunk-find-overrides`** - Find all method overrides across the inheritance chain

These tools help you understand type hierarchies, trace inheritance relationships, and analyze how types are related in your codebase.

#### `spelunk-find-method-calls`
**MCP Description**: "Find all methods called by a specific method (call tree analysis)"

**Purpose**: Analyze what methods are called BY a specific method (outgoing calls).

**Input Format**:
```json
{
  "methodName": "ProcessOrder",        // Required: method to analyze
  "className": "OrderService",        // Required: containing class
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Method calls from OrderService.ProcessOrder:

Direct calls (5):
1. ValidateOrder (line 25)
   Target: OrderValidator.ValidateOrder
   Location: /path/src/OrderService.cs:25:13

2. SaveOrder (line 30)
   Target: OrderRepository.SaveOrder
   Location: /path/src/OrderService.cs:30:9
   
3. SendNotification (line 35)
   Target: NotificationService.SendNotification
   Location: /path/src/OrderService.cs:35:9
```

**Use Case**: Understand method dependencies, trace execution flow, identify external dependencies

#### `spelunk-find-method-callers`
**MCP Description**: "Find all methods that call a specific method (caller tree analysis)"

**Purpose**: Find all places that CALL a specific method (incoming calls).

**Input Format**:
```json
{
  "methodName": "SaveOrder",           // Required: method being called
  "className": "OrderRepository",     // Required: containing class
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Methods calling OrderRepository.SaveOrder:

Found 3 caller(s):
1. OrderService.ProcessOrder
   Location: /path/src/OrderService.cs:30:9
   Call: await _repository.SaveOrder(order);
   
2. OrderService.UpdateOrder
   Location: /path/src/OrderService.cs:55:13
   Call: _repository.SaveOrder(updatedOrder);
   
3. OrderImporter.ImportOrders
   Location: /path/src/OrderImporter.cs:120:17
   Call: repo.SaveOrder(importedOrder);
```

**Use Case**: Impact analysis before changes, understand usage patterns, find all consumers

#### `spelunk-find-references`
**MCP Description**: "Find all references to a type, method, property, or field"

**Purpose**: Find all usages of any symbol across the codebase.

**Input Format**:
```json
{
  "symbolName": "User",                // Required: symbol to find
  "symbolType": "type",               // Required: type|method|property|field
  "containerName": "UserService",     // Optional: for methods/properties/fields
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 12 reference(s) to 'User' (type):

1. Variable declaration
   Location: /path/src/UserService.cs:25:9
   Context: User user = await GetUser(id);
   
2. Method parameter
   Location: /path/src/UserValidator.cs:10:30
   Context: public bool ValidateUser(User user)
   
3. Return type
   Location: /path/src/UserRepository.cs:15:12
   Context: public Task<User> FindById(int id)
```

**Use Case**: Find all usages before renaming, understand symbol dependencies, locate all consumers

#### `spelunk-find-implementations`
**MCP Description**: "Find all implementations of an interface or abstract class"

**Purpose**: Discover all concrete implementations of interfaces or abstract classes.

**Input Format**:
```json
{
  "interfaceName": "IUserService",     // Required: interface or abstract class
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 3 implementation(s) of 'IUserService':

1. UserService
   Location: /path/src/Services/UserService.cs:8:1
   Type: class
   Implements: IUserService, IDisposable
   
2. MockUserService
   Location: /path/tests/Mocks/MockUserService.cs:5:1
   Type: class
   Implements: IUserService
   
3. CachedUserService
   Location: /path/src/Services/CachedUserService.cs:10:1
   Type: class
   Implements: IUserService
   Base: UserService
```

**Use Case**: Find all implementations for testing, understand service variations, locate mock implementations

#### `spelunk-find-overrides`
**MCP Description**: "Find all overrides of a virtual or abstract method"

**Purpose**: Find all methods that override a virtual or abstract method.

**Input Format**:
```json
{
  "methodName": "SaveChanges",         // Required: virtual/abstract method
  "className": "BaseRepository",      // Required: declaring class
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 4 override(s) of 'BaseRepository.SaveChanges':

1. UserRepository.SaveChanges
   Location: /path/src/Repositories/UserRepository.cs:45:5
   Signature: public override async Task<int> SaveChanges()
   Adds: Async behavior
   
2. AuditableRepository.SaveChanges
   Location: /path/src/Repositories/AuditableRepository.cs:30:5
   Signature: public override async Task<int> SaveChanges()
   Adds: Audit logging
```

**Use Case**: Understand customization points, track override implementations, ensure consistent behavior

#### `spelunk-find-derived-types`
**MCP Description**: "Find all types that derive from a base class"

**Purpose**: Discover all classes that inherit from a specific base class.

**Input Format**:
```json
{
  "baseClassName": "ControllerBase",   // Required: base class name
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 5 type(s) deriving from 'ControllerBase':

1. UserController
   Location: /path/src/Controllers/UserController.cs:8:1
   Direct parent: ControllerBase
   Implements: IUserController
   
2. ApiControllerBase
   Location: /path/src/Controllers/ApiControllerBase.cs:5:1
   Direct parent: ControllerBase
   Abstract: Yes
   
3. ProductController
   Location: /path/src/Controllers/ProductController.cs:10:1
   Direct parent: ApiControllerBase
   Inheritance chain: ProductController -> ApiControllerBase -> ControllerBase
```

**Use Case**: Map inheritance hierarchies, find all subclasses for refactoring, understand type relationships

### 4. Statement-Level Operations

#### `spelunk-find-statements`
**MCP Description**: "Find statements in code matching a pattern. Returns statement IDs for use with other operations. Uses Roslyn's syntax tree to enumerate all statements."

**Purpose**: Search for statements matching text or regex patterns for analysis or bulk operations.

**Input Format:**
```json
{
  "pattern": "Console.WriteLine",      // Required: text, regex, or RoslynPath pattern
  "patternType": "text",              // Optional: "text" (default), "regex", or "roslynpath"
  "scope": {                          // Optional: limit search scope
    "file": "/path/to/file.cs",
    "className": "UserService",
    "methodName": "ProcessUser"
  },
  "includeNestedStatements": true,    // Optional: include statements in blocks
  "groupRelated": false,              // Optional: group related statements
  "workspacePath": "/path/to/search"  // Optional
}
```

**Pattern Types:**
- **text** (default): Simple text search within statement text
- **regex**: Regular expression pattern matching
- **roslynpath**: XPath-style queries for sophisticated matching

**RoslynPath Examples:**
- `//statement[@contains='TODO']` - Find TODO comments
- `//method[Get*]//statement[@type=ThrowStatement]` - Throws in Get methods
- `//method[@async]//statement[@type=ReturnStatement and not(@contains='await')]` - Non-awaited returns in async methods
- `//foreach//expression[@contains='.First(']` - Potential N+1 query patterns
- `//class[*Service]//statement[@type=IfStatement and @contains='== null']` - Null checks in service classes

**Output Format**:
```text
Found 3 statement(s) matching 'Console.WriteLine':

1. Statement ID: stmt-1
   Location: /path/src/Program.cs:10:9
   Context: Method 'Main' in class 'Program'
   Statement: Console.WriteLine("Starting application...");
   
2. Statement ID: stmt-2
   Location: /path/src/UserService.cs:25:13
   Context: Method 'LogUser' in class 'UserService'
   Statement: Console.WriteLine($"User {user.Name} logged in");
```

**Pattern Examples**:
- `"Console.WriteLine"` - Find all console output
- `"new .*Exception"` (regex) - Find exception creation
- `"await .*Async\\("` (regex) - Find async calls
- `"if \\(.*== null\\)"` (regex) - Find null checks

**Use Case**: Find patterns for refactoring, locate logging statements, identify async patterns

#### `spelunk-replace-statement`
**MCP Description**: "Replace a statement with new code. The statement is identified by its location from find-statements. Preserves indentation and formatting context."

**Purpose**: Replace an entire statement at a specific location.

**Input Format**:
```json
{
  "location": {                       // Required: exact location
    "file": "/path/to/file.cs",
    "line": 25,
    "column": 9
  },
  "newStatement": "logger.LogInfo(\"User logged in\");",  // Required
  "preserveComments": true,           // Optional: keep existing comments
  "workspacePath": "/path/to/search"  // Optional
}
```

**Alternative Input** (with statementId from find-statements):
```json
{
  "statementId": "stmt-123",           // From find-statements
  "newStatement": "logger.LogInfo(\"User logged in\");",
  "preserveComments": true
}
```

**Output Format**:
```text
Statement replaced successfully in /path/to/file.cs

Original: Console.WriteLine("User logged in");
New: logger.LogInfo("User logged in");

Preview:
Before:
  23:     public void LogUser(User user)
  24:     {
  25:         Console.WriteLine("User logged in");
  26:         ProcessUser(user);

After:
  23:     public void LogUser(User user)
  24:     {
  25:         logger.LogInfo("User logged in");
  26:         ProcessUser(user);
```

**Use Case**: Replace logging methods, update API calls, modernize syntax

#### `spelunk-insert-statement`
**MCP Description**: "Insert a new statement before or after an existing statement. The reference statement is identified by its location from find-statements. Preserves indentation and formatting context."

**Purpose**: Add new statements relative to existing code.

**Input Format**:
```json
{
  "position": "before",                // Required: "before" or "after"
  "location": {                       // Required: reference location
    "file": "/path/to/file.cs",
    "line": 30,
    "column": 9
  },
  "statement": "ArgumentNullException.ThrowIfNull(user);",  // Required
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Statement inserted successfully in /path/to/file.cs

Inserted before line 30:
ArgumentNullException.ThrowIfNull(user);

Preview:
Before:
  28:     public void ProcessUser(User user)
  29:     {
  30:         var result = ValidateUser(user);
  31:         SaveUser(user);

After:
  28:     public void ProcessUser(User user)
  29:     {
  30:         ArgumentNullException.ThrowIfNull(user);
  31:         var result = ValidateUser(user);
  32:         SaveUser(user);
```

**Use Case**: Add validation, insert logging, add null checks, insert using statements

#### `spelunk-remove-statement`
**MCP Description**: "Remove a statement from the code. The statement is identified by its location from find-statements. Can preserve comments attached to the statement."

**Purpose**: Delete statements while optionally preserving their comments.

**Input Format**:
```json
{
  "location": {                       // Required: statement location
    "file": "/path/to/file.cs",
    "line": 45,
    "column": 9
  },
  "preserveComments": true,           // Optional: default true
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Statement removed successfully from /path/to/file.cs

Removed: Console.WriteLine("Debug info");
Preserved comment: // TODO: Replace with proper logging

Preview:
Before:
  43:     public void DebugMethod()
  44:     {
  45:         // TODO: Replace with proper logging
  46:         Console.WriteLine("Debug info");
  47:         ProcessData();

After:
  43:     public void DebugMethod()
  44:     {
  45:         // TODO: Replace with proper logging
  46:         ProcessData();
```

**Use Case**: Remove debug code, clean up obsolete statements, remove commented-out code

### 5. Ephemeral Marker System

#### `spelunk-mark-statement`
**MCP Description**: "Mark a statement with an ephemeral marker for later reference. Markers are session-scoped and not persisted."

**Purpose**: Tag statements with temporary identifiers that survive through code edits.

**Input Format**:
```json
{
  "location": {                       // Required: statement location
    "file": "/path/to/file.cs",
    "line": 25,
    "column": 9
  },
  "label": "First output",            // Optional: descriptive label
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Statement marked successfully
Marker ID: mark-1
Label: First output
Statement: Console.WriteLine("Hello, World!");
Location: /path/to/file.cs:25:9
Context: Program.Main
```

**Use Case**: Track statements through multi-step refactoring, maintain references during transformations

#### `spelunk-find-marked-statements`
**MCP Description**: "Find all or specific marked statements. Returns current locations even if code has been edited."

**Purpose**: Locate previously marked statements, even after code modifications.

**Input Format**:
```json
{
  "markerId": "mark-1",                // Optional: specific marker
  "file": "/path/to/file.cs",        // Optional: filter by file
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 3 marked statement(s)
Total markers in session: 3

Marker ID: mark-1
Label: First output
Location: /path/to/file.cs:25:9
Context: Method: Main
Statement: Console.WriteLine("Hello, World!");

Marker ID: mark-2
Label: Result output
Location: /path/to/file.cs:30:9
Context: Method: Main
Statement: Console.WriteLine($"Result: {result}");
```

**Use Case**: Find marked statements after edits, track multiple related statements

#### `spelunk-unmark-statement`
**MCP Description**: "Remove a specific marker by its ID."

**Purpose**: Clean up individual markers when no longer needed.

**Input Format**:
```json
{
  "markerId": "mark-2",                // Required: marker to remove
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Marker 'mark-2' removed successfully
Remaining markers: 2
```

**Use Case**: Remove completed markers, clean up after specific operations

#### `spelunk-clear-markers`
**MCP Description**: "Clear all markers in the current session."

**Purpose**: Reset all markers when starting new operations.

**Input Format**:
```json
{
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Cleared 3 marker(s)
```

**Use Case**: Reset marker state, clean up after complex refactoring

#### `spelunk-get-statement-context`
**MCP Description**: "Get comprehensive semantic context for a statement including symbols, types, diagnostics, and basic data flow"

**Purpose**: Provides deep semantic information about a statement for AI agents to understand code context hierarchically.

**Input Format**:
```json
{
  "statementId": "stmt-abc123",       // Option 1: Use statement ID from find-statements
  
  // Option 2: Use direct location
  "file": "/path/to/file.cs",         // File path
  "line": 15,                         // Line number (1-based)
  "column": 9,                        // Column number (1-based)
  
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```json
{
  "statement": {
    "id": "stmt-abc123",
    "code": "var user = await GetUserAsync(userId);",
    "kind": "LocalDeclarationStatement",
    "location": {
      "file": "/path/to/file.cs",
      "line": 15,
      "column": 9,
      "endLine": 15,
      "endColumn": 47
    }
  },
  "semanticInfo": {
    "symbols": [
      {
        "name": "user",
        "kind": "Local",
        "type": "User",
        "isDeclared": true,
        "isImplicitlyTyped": true
      },
      {
        "name": "GetUserAsync",
        "kind": "Method",
        "type": "Method",
        "containingType": "UserService",
        "returnType": "Task<User>",
        "parameters": [
          { "name": "userId", "type": "int" }
        ],
        "declarationLocation": {
          "file": "/path/src/UserService.cs",
          "line": 42,
          "column": 12
        }
      }
    ],
    "typeInfo": {
      "expressionType": "Task<User>",
      "convertedType": "Task<User>",
      "isImplicitConversion": false
    },
    "dataFlow": {
      "variablesRead": ["userId"],
      "variablesDeclared": ["user"],
      "variablesWritten": ["user"]
    }
  },
  "context": {
    "enclosingSymbol": {
      "name": "ProcessUserRequest",
      "kind": "Method",
      "containingType": "UserController"
    },
    "enclosingBlock": {
      "kind": "Block",
      "statementCount": 5,
      "currentIndex": 2
    },
    "availableSymbols": [
      { "name": "userId", "kind": "Parameter", "type": "int" },
      { "name": "_logger", "kind": "Field", "type": "ILogger" }
    ],
    "usings": [
      "System",
      "System.Threading.Tasks",
      "MyApp.Models"
    ]
  },
  "diagnostics": [],
  "suggestions": {
    "canExtractMethod": true,
    "canInlineVariable": false,
    "possibleRefactorings": [
      "Extract Method",
      "Add Null Check"
    ]
  }
}
```

**Use Case**: Hierarchical context walking for AI agents, semantic-aware code modification, diagnostic-driven fixes

#### `spelunk-get-data-flow`
**MCP Description**: "Get comprehensive data flow analysis for a code region showing variable usage, dependencies, and control flow"

**Purpose**: Provides deep data flow analysis to understand how variables flow through code, detect dependencies, and identify potential issues.

**Input Format**:
```json
{
  "file": "/path/to/file.cs",              // Required: file to analyze
  "startLine": 10,                         // Required: start line (1-based)
  "startColumn": 5,                        // Required: start column (1-based)
  "endLine": 20,                           // Required: end line (1-based)
  "endColumn": 30,                         // Required: end column (1-based)
  "includeControlFlow": true,              // Optional: include control flow analysis (default: true)
  "workspacePath": "/path/to/workspace"    // Optional
}
```

**Output Format**:
```json
{
  "region": {
    "file": "/path/to/file.cs",
    "startLine": 10,
    "startColumn": 5,
    "endLine": 20,
    "endColumn": 30,
    "code": "int sum = x + y;\nint product = x * y;\nreturn sum + product;"
  },
  "dataFlow": {
    "dataFlowsIn": ["x", "y"],              // Variables that flow into the region
    "dataFlowsOut": ["result"],             // Variables that flow out of the region
    "alwaysAssigned": ["sum", "product"],   // Variables always assigned
    "readInside": ["x", "y", "sum", "product"],
    "writtenInside": ["sum", "product", "result"],
    "readOutside": [],
    "writtenOutside": ["logger"],
    "captured": ["localVar"],               // Variables captured by closures
    "capturedInside": [],
    "unsafeAddressTaken": []
  },
  "controlFlow": {                          // May be null if region invalid
    "alwaysReturns": true,                  // Uses Roslyn's control flow API
    "endPointIsReachable": false,
    "startPointIsReachable": true,
    "returnStatements": 1,
    "hasYieldStatements": false,
    "exitPoints": ["Return", "Throw"]
  },
  "variableFlows": [
    {
      "name": "sum",
      "type": "int",
      "declaredAt": "10:9",
      "readLocations": ["12:20", "12:35"],
      "writeLocations": ["10:9"],
      "isDefinitelyAssignedOnEntry": false,
      "isDefinitelyAssignedOnExit": true,
      "mayBeUnassigned": false
    }
  ],
  "dependencies": [
    {
      "variable": "result",
      "dependsOn": ["sum", "product"],
      "reason": "Initialization"
    }
  ],
  "warnings": [
    {
      "type": "UnusedVariable",
      "message": "Variable 'temp' is declared but never used",
      "variable": "temp",
      "location": "15:13"
    },
    {
      "type": "UninitializedRead",
      "message": "Variable 'x' may be used before being initialized",
      "variable": "x",
      "location": "16:25"
    }
  ]
}
```

**Notes**: 
- Data flow analysis is robust and works on partial code regions
- Control flow analysis returns null if region contains partial/invalid statements
- Set `includeControlFlow: false` to skip control flow for better performance

**Use Case**: Complex refactoring planning, dead code detection, dependency analysis, null safety verification

### 6. Code Modification Tools

#### `spelunk-rename-symbol`
**MCP Description**: "Rename a symbol (type, method, property, field) and update all references"

**Purpose**: Safely rename any symbol across the entire codebase with all references updated.

**Input Format**:
```json
{
  "oldName": "GetUser",                // Required: current name
  "newName": "GetUserById",            // Required: new name
  "symbolType": "method",              // Required: type|method|property|field
  "containerName": "UserService",     // Optional: for methods/properties/fields
  "workspacePath": "/path/to/apply",  // Optional
  "preview": false                    // Optional: preview without applying
}
```

**Output Format**:
```text
Renamed 'GetUser' to 'GetUserById' in 8 location(s):

1. Method definition
   Location: /path/src/UserService.cs:15:12
   Change: public async Task<User> GetUser(int id)
        -> public async Task<User> GetUserById(int id)

2. Method call
   Location: /path/src/UserController.cs:25:20
   Change: var user = await _service.GetUser(userId);
        -> var user = await _service.GetUserById(userId);

3. Interface definition
   Location: /path/src/IUserService.cs:8:5
   Change: Task<User> GetUser(int id);
        -> Task<User> GetUserById(int id);
```

**Use Case**: Refactor method names, update property names, rename types consistently

#### `spelunk-edit-code`
**MCP Description**: "Perform surgical code edits using Roslyn. Operations: add-method, add-property, make-async, add-parameter, wrap-try-catch"

**Purpose**: Perform complex structural edits beyond simple text replacement.

**Input Format**:
```json
{
  "file": "/path/to/file.cs",         // Required: file to edit
  "operation": "add-method",          // Required: operation type
  "className": "UserService",        // Required: target class
  "methodName": "ValidateUser",      // For method operations
  "code": "method code here",        // For add operations
  "parameters": {                    // Operation-specific parameters
    "parameterName": "cancellationToken",
    "parameterType": "CancellationToken",
    "defaultValue": "default"
  },
  "preview": false                   // Optional: preview only
}
```

**Operations**:

1. **add-method**: Add a new method to a class
   ```json
   {
     "operation": "add-method",
     "code": "public async Task<bool> ValidateUser(User user)\n{\n    return user != null && user.IsActive;\n}"
   }
   ```

2. **add-property**: Add a new property to a class
   ```json
   {
     "operation": "add-property",
     "code": "public DateTime LastModified { get; set; }"
   }
   ```

3. **make-async**: Convert method to async
   ```json
   {
     "operation": "make-async",
     "methodName": "ProcessData"
   }
   ```

4. **add-parameter**: Add parameter to method
   ```json
   {
     "operation": "add-parameter",
     "methodName": "ProcessUser",
     "parameters": {
       "parameterName": "options",
       "parameterType": "ProcessOptions",
       "defaultValue": "null"
     }
   }
   ```

5. **wrap-try-catch**: Wrap method body in try-catch
   ```json
   {
     "operation": "wrap-try-catch",
     "methodName": "SaveData",
     "parameters": {
       "catchType": "Exception",
       "logError": true
     }
   }
   ```

**Output Format**:
```text
Operation 'add-method' completed successfully

Added method 'ValidateUser' to class 'UserService'
Location: /path/src/UserService.cs:45:5

Preview:
  43:     }
  44:     
  45:     public async Task<bool> ValidateUser(User user)
  46:     {
  47:         return user != null && user.IsActive;
  48:     }
  49: }
```

**Use Case**: Add methods/properties, convert to async, add parameters, add error handling

#### `spelunk-fix-pattern` (DEPRECATED)
**MCP Description**: "Transform code using semantic-aware patterns with RoslynPath queries and statement-level operations"

> **‚ö†Ô∏è DEPRECATED**: This tool represents a monolithic refactoring approach. Refactorings should be implemented as agent workflows using primitive tools. See [REFACTORING_AS_AGENTS.md](REFACTORING_AS_AGENTS.md) for the new approach. This tool is retained for backward compatibility only.

**Purpose**: Apply powerful semantic-aware transformations using RoslynPath queries and statement-level operations.

**Input Format**:
```json
{
  "findPattern": "//statement[@contains='Console.WriteLine']",  // RoslynPath or text pattern
  "replacePattern": "logger.LogInfo",                          // For custom transformations
  "patternType": "convert-to-interpolation",                   // Transformation type
  "workspacePath": "/path/to/apply",                          // Optional
  "preview": true                                              // Optional: preview changes
}
```

**Transformation Types**:
- `add-null-check`: Add ArgumentNullException.ThrowIfNull before method calls
- `convert-to-async`: Convert sync methods to async (e.g., ReadAllText ‚Üí ReadAllTextAsync)
- `extract-variable`: Extract complex expressions into variables
- `simplify-conditional`: Convert if-null checks to null-conditional operators (?.)
- `parameterize-query`: Convert SQL string concatenation to parameterized queries
- `convert-to-interpolation`: Convert string.Format to string interpolation ($"")
- `add-await`: Add missing await keywords to async method calls
- `custom`: Apply custom text replacement (uses replacePattern)

**Legacy Pattern Types** (for backward compatibility):
- `method-call`, `async-usage`, `null-check`, `string-format`

**Example - Add Null Checks**:
```json
{
  "findPattern": "//statement[@type=ExpressionStatement and @contains='.']",
  "patternType": "add-null-check",
  "preview": true
}
```

**Example - Convert to Async**:
```json
{
  "findPattern": "//method[*Async]//statement[@contains='File.Read']",
  "patternType": "convert-to-async",
  "preview": true
}
```

**Output Format**:
```json
{
  "Success": true,
  "Fixes": [
    {
      "FilePath": "/path/src/Program.cs",
      "Line": 10,
      "Column": 9,
      "OriginalCode": "Console.WriteLine(msg);",
      "ReplacementCode": "ArgumentNullException.ThrowIfNull(console);\nConsole.WriteLine(msg);",
      "Description": "Apply AddNullCheck transformation"
    }
  ]
}
```

**Use Case**: Add null safety, modernize async patterns, improve code quality, refactor with semantic understanding

### 7. Enhanced AST Navigation Tools

#### `spelunk-query-syntax`
**MCP Description**: "Query any syntax node using enhanced RoslynPath with full AST navigation"

**Purpose**: Query the abstract syntax tree using enhanced RoslynPath expressions that support low-level node types and advanced navigation.

**Input Format**:
```json
{
  "roslynPath": "//binary-expression[@operator='==' and @right-text='null']",
  "file": "/path/to/specific/file.cs",     // Optional: specific file to search
  "workspacePath": "workspace-id",         // Optional: workspace to search in
  "includeContext": true,                  // Optional: include surrounding context
  "contextLines": 2,                       // Optional: number of context lines
  "includeSemanticInfo": true              // Optional: include semantic information (types, symbols)
}
```

**Output Format**:
```json
{
  "matches": [
    {
      "node": {
        "type": "BinaryExpression",
        "kind": "EqualsExpression",
        "text": "user == null",
        "location": { "line": 42, "column": 12 }
      },
      "path": "UserService/Process/statement[stmt-123]",
      "semanticInfo": {                    // Only if includeSemanticInfo: true
        "type": {
          "name": "bool",
          "kind": "Primitive"
        },
        "enclosingContext": {
          "symbol": "UserService.Process(User)",
          "kind": "Method"
        }
      }
    }
  ]
}
```

**Use Case**: Find specific patterns in code using detailed AST queries (null comparisons, complex expressions, specific node types)

#### `spelunk-navigate`  
**MCP Description**: "Navigate from a position using RoslynPath axes (ancestor::, following-sibling::, etc.)"

**Purpose**: Navigate the syntax tree from a specific position using XPath-style axes to find related code elements.

**Input Format**:
```json
{
  "from": {
    "file": "/path/to/file.cs",
    "line": 42,
    "column": 15
  },
  "path": "ancestor::method[1]/following-sibling::method[1]",
  "returnPath": true,  // Optional: return the RoslynPath of the target
  "includeSemanticInfo": true  // Optional: include semantic information
}
```

**Output Format**:
```json
{
  "navigatedTo": {
    "type": "MethodDeclaration",
    "name": "ProcessNext",
    "location": { "line": 50, "column": 5 },
    "path": "//class[UserService]/method[ProcessNext]",
    "semanticInfo": {                    // Only if includeSemanticInfo: true
      "declaredSymbol": {
        "name": "ProcessNext",
        "kind": "Method",
        "isAsync": false
      }
    }
  }
}
```

**Use Case**: Navigate between related code elements (find next method, parent class, enclosing block, sibling statements)

#### `spelunk-get-ast`
**MCP Description**: "Get AST structure for understanding code hierarchy"

**Purpose**: Retrieve the abstract syntax tree structure for a file or specific node to understand code organization and hierarchy.

**Input Format**:
```json
{
  "file": "/path/to/file.cs",
  "root": "//method[Process]",    // Optional: RoslynPath to root node
  "depth": 3,                     // Optional: tree depth (default: 3)
  "includeTokens": false,         // Optional: include syntax tokens
  "format": "tree",               // Optional: output format (default: "tree")
  "includeSemanticInfo": true     // Optional: include semantic information
}
```

**Output Format**:
```json
{
  "ast": {
    "type": "MethodDeclaration",
    "name": "Process",
    "semanticInfo": {               // Only if includeSemanticInfo: true
      "declaredSymbol": {
        "name": "Process",
        "kind": "Method"
      }
    },
    "children": [
      {
        "type": "ParameterList",
        "children": [
          {
            "type": "Parameter",
            "name": "user",
            "type": "User"
          }
        ]
      },
      {
        "type": "Block",
        "children": [
          {
            "type": "IfStatement",
            "children": [
              {
                "type": "BinaryExpression",
                "operator": "==",
                "left": { "type": "Identifier", "name": "user" },
                "right": { "type": "Literal", "value": "null" }
              }
            ]
          }
        ]
      }
    ]
  }
}
```

**Use Case**: Understand code structure, learn AST node types, debug RoslynPath queries, analyze code patterns

## Usage Patterns

### 1. Discovery ‚Üí Analysis ‚Üí Modification
```
1. find-class "Repository" ‚Üí Locate target classes
2. find-method-calls ‚Üí Understand dependencies  
3. mark-statement ‚Üí Mark areas of interest
4. replace-statement ‚Üí Make modifications
```

### 2. Impact Analysis Before Changes
```
1. find-references ‚Üí See all usages
2. find-overrides ‚Üí Check inheritance impact
3. rename-symbol ‚Üí Safe rename with preview
```

### 3. Pattern-Based Refactoring
```
1. find-statements "Console.WriteLine" ‚Üí Find all logging
2. mark-statement (multiple) ‚Üí Mark statements to change
3. Loop: replace-statement ‚Üí Update each to use logger
4. clear-markers ‚Üí Clean up
```

### 4. Multi-Step Refactoring with Markers
```
1. find-statements "async.*{" ‚Üí Find async methods
2. mark-statement ‚Üí Mark each method
3. find-statements "(?<!await ).*Async\\(" ‚Üí Find non-awaited async calls
4. Loop through marked methods:
   - find-marked-statements ‚Üí Get method
   - insert-statement "await" ‚Üí Add await keyword
5. clear-markers ‚Üí Clean up
```

### 5. Diagnostic-Driven Error Resolution with Context Walking

#### Roslyn Node Identification Integration

**Built-in Roslyn Tracking Mechanisms:**
- **TextSpan**: Every diagnostic provides precise line/column location via TextSpan
- **SyntaxAnnotation**: Roslyn's persistent node tagging system (used by our markers)
- **TrackNodes**: Editor integration for maintaining references through edits

**Diagnostic ‚Üí Marker ‚Üí Fix Workflow:**
```
1. dotnet-get-diagnostics ‚Üí Provides TextSpan location (line:column)
2. mark-statement ‚Üí Converts TextSpan to SyntaxAnnotation marker (edit-resilient)
3. Apply fixes using marker references (not line numbers)
4. Markers survive code edits during multi-step resolution
```

**Key Insight**: Our "ephemeral" markers are actually built on Roslyn's robust SyntaxAnnotation system, providing stable references that survive syntax tree transformations.

**Hierarchical Context Analysis Pattern:**
```
1. dotnet-get-diagnostics ‚Üí Get compilation errors with precise locations
2. mark-statement ‚Üí Mark the error location for stable reference
3. Context Walking (expand outward as needed):
   a. Error statement: //statement[@markerId='mark-1']
   b. Enclosing block: //statement[@markerId='mark-1']/ancestor::*[1] 
   c. Sibling statements: //statement[@markerId='mark-1']/ancestor::*[1]/../*
   d. Parent method: //statement[@markerId='mark-1']/ancestor::method[1]
   e. Parent class: //statement[@markerId='mark-1']/ancestor::class[1]
4. mark-statement ‚Üí Mark relevant context levels
5. Targeted resolution using context + error type
6. clear-markers ‚Üí Clean up when done
```

**Error-Specific Resolution Workflows:**

**CS0103 (Undeclared Variable):**
```
1. Mark error location ‚Üí mark-1
2. Find enclosing method context ‚Üí mark-2  
3. Check variable declarations in scope via siblings
4. Resolution options:
   - replace-statement ‚Üí Fix assignment (int variable = value)
   - remove-statement ‚Üí Remove invalid assignment
   - insert-statement ‚Üí Add variable declaration above
```

**CS1061 (Missing Method):**
```
1. Mark error location ‚Üí mark-1
2. Find object type via context analysis
3. Resolution options:
   - replace-statement ‚Üí Fix method name (find similar methods)
   - remove-statement ‚Üí Remove invalid call
   - find-symbols + insert-statement ‚Üí Add missing method to target class
```

**CS0029 (Type Mismatch):**
```
1. Mark error location ‚Üí mark-1
2. Analyze expected vs actual types from context
3. Resolution options:
   - replace-statement ‚Üí Fix type (string x = "value" or int x = 42)
   - insert-statement ‚Üí Add type conversion
   - replace-statement ‚Üí Change variable type declaration
```

**CS0246 (Missing Type):**
```
1. Mark error location ‚Üí mark-1
2. Check file-level using statements and available types
3. Resolution options:
   - insert-statement ‚Üí Add using statement at file top
   - replace-statement ‚Üí Use existing type (object, var, etc.)
   - insert-statement ‚Üí Add missing class/interface definition
```

**Example: Complete Error Resolution Workflow**
```
# Diagnostic shows: CS0103 at Program.cs:14:9 - 'undeclaredVariable' does not exist

1. mark-statement(location: line 14, col 9) ‚Üí mark-1 "error_location"

2. Context walking with markers:
   - mark-statement(roslynPath: "//statement[@markerId='mark-1']/ancestor::method[1]") ‚Üí mark-2 "method_context"
   - find-statements(pattern: "//statement[@markerId='mark-2']//statement[@type='VariableDeclaration']") ‚Üí See existing variables
   - find-statements(pattern: "//statement[@markerId='mark-1']/following-sibling::statement[1]") ‚Üí Check next statement

3. Analysis reveals: undeclaredVariable = subtotal + tax; followed by order.Total = total;
   Context suggests: should be "var total = subtotal + tax;"

4. replace-statement(markerId: "mark-1", newStatement: "var total = subtotal + tax;")

5. Verification: dotnet-get-diagnostics ‚Üí Confirm CS0103 resolved

6. clear-markers ‚Üí Clean up session
```

## Best Practices

1. **Always Load First**: Call `load-workspace` before any operations
2. **Start with Diagnostics**: Use `spelunk-get-diagnostics` to identify compilation errors before manual analysis
3. **Mark Before Modify**: Use `mark-statement` to create stable references that survive edits
4. **Context Walking**: Expand analysis hierarchically - statement ‚Üí enclosing ‚Üí siblings ‚Üí method ‚Üí class
5. **Verify Fixes**: Re-run `spelunk-get-diagnostics` after changes to confirm resolution
6. **Clean Up Markers**: Use `clear-markers` after complex operations to avoid session bloat
7. **Preview Changes**: Most modification tools show previews - review them carefully
8. **Combine Tools**: Use discovery tools to find targets, then modification tools to change them
9. **RoslynPath for Stability**: Prefer RoslynPath queries over text patterns for precise syntax tree navigation

## Tool Composition Examples

### Adding Logging to All Public Methods
```
1. find-method ‚Üí Find all public methods
2. For each method:
   - mark-statement ‚Üí Mark method start
   - insert-statement ‚Üí Add entry logging
   - find-statements "return" ‚Üí Find return statements
   - insert-statement ‚Üí Add exit logging before returns
```

### Converting Synchronous to Async
```
1. find-method-calls ‚Üí Find methods calling async operations
2. mark-statement ‚Üí Mark these methods
3. For each marked method:
   - edit-code ‚Üí Add async keyword to signature
   - edit-code ‚Üí Change return type to Task<T>
   - find-method-callers ‚Üí Find callers
   - Loop: Add await to call sites
```

### Extracting Magic Numbers
```
1. find-statements "[0-9]+" ‚Üí Find numeric literals
2. mark-statement ‚Üí Mark each occurrence
3. insert-statement ‚Üí Add constants at class level
4. replace-statement ‚Üí Replace literals with constants
5. clear-markers ‚Üí Clean up
```

## Tool Implementation Status

### Fully Implemented (28 tools)
- ‚úÖ Workspace: load-workspace, workspace-status, get-diagnostics
- ‚úÖ Discovery: find-class, find-method, find-property
- ‚úÖ Relationships: find-method-calls, find-method-callers, find-references, find-implementations, find-overrides, find-derived-types
- ‚úÖ Statements: find-statements, replace-statement, insert-statement, remove-statement
- ‚úÖ Markers: mark-statement, find-marked-statements, unmark-statement, clear-markers
- ‚úÖ Refactoring: rename-symbol, edit-code, fix-pattern
- ‚úÖ AST Navigation: query-syntax, navigate, get-ast

### Not Implemented (3 tools)
- ‚ùå analyze-syntax: Syntax tree analysis (placeholder)
- ‚ùå get-symbols: Symbol retrieval at position (placeholder)
- ‚ùå find-namespace: Namespace discovery (not in tool list)

## Important Notes

### General Guidelines
- All find operations are read-only and don't modify code
- File paths must be absolute paths (not relative)
- Most tools support `preview` mode to review changes before applying
- Pattern matching uses .NET regex syntax when `patternType: "regex"`
- Workspace must be loaded before any analysis/modification operations

### Statement Operations
- Statement IDs (stmt-123) are ephemeral and session-scoped
- Locations use 1-based line and column numbers
- Statement operations preserve indentation automatically
- Comments can be preserved when removing statements

### Marker System
- Markers are session-scoped and not persisted to disk
- Markers survive through normal code edits
- Markers are lost when files are reloaded from disk
- Maximum 100 markers per session
- Markers use Roslyn's SyntaxAnnotation internally

### Symbol Operations
- Symbol types: `type`, `method`, `property`, `field`
- Container name required for methods/properties/fields
- Rename operations update all references across workspace
- Preview mode recommended for large-scale changes

## Error Handling

All tools return structured error responses:
```text
Error: <error message>
```

Common errors:
- "Workspace not loaded" - Call load-workspace first
- "Symbol not found" - Check symbol name and type
- "Location not found" - Verify file path and line/column
- "Pattern syntax error" - Check regex syntax for regex patterns
- "Marker not found" - Marker ID doesn't exist

## Performance Considerations

1. **Large Codebases**: Find operations may take time on large solutions
2. **Pattern Complexity**: Complex regex patterns impact performance
3. **Workspace Loading**: Initial load can be slow for large solutions
4. **Symbol Resolution**: Cross-assembly references may be slower
5. **Batch Operations**: Use markers to batch related changes efficiently