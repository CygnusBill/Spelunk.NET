# MCP Roslyn Tools Synopsis

## Overview

The MCP Roslyn Server provides a comprehensive set of tools for multi-language code analysis, navigation, and manipulation at various granularities. These tools are designed to be composable, allowing agents to perform complex refactoring operations through coordinated use of multiple tools.

## Supported Languages

- **C#** - Full support via Roslyn compiler services
- **VB.NET** - Full support via Roslyn compiler services with language-agnostic mapping
- **F#** - Basic support via FSharp.Compiler.Service (separate from Roslyn)

### Language-Agnostic Features
The server provides unified abstractions across supported languages:
- C# `void` methods ↔ VB.NET `Sub` procedures
- C# `static` ↔ VB.NET `Shared`
- C# `abstract` ↔ VB.NET `MustInherit`
- C# `virtual` ↔ VB.NET `Overridable`
- C# `override` ↔ VB.NET `Overrides`

## Format Conventions

### Location Format
Many tools accept or return location objects:
```json
{
  "file": "/absolute/path/to/file.cs",
  "line": 42,      // 1-based line number
  "column": 9      // 1-based column number
}
```

### RoslynPath Format (New - More Stable)
RoslynPath provides stable code references that survive edits:
```json
{
  "roslynPath": "//class[UserService]/method[GetUser]/block/statement[1]",
  "file": "/absolute/path/to/file.cs"
}
```

**Common RoslynPath Patterns:**
- `//method[ProcessOrder]` - Find method named ProcessOrder
- `//method[@async]` - Find all async methods
- `//statement[@contains='Console.WriteLine']` - Find console output
- `//statement[@type=IfStatement and @contains='null']` - Find null checks
- See [ROSLYN_PATH_INSTRUCTIONS.md](./ROSLYN_PATH_INSTRUCTIONS.md) for full syntax

### Pattern Syntax
- **Wildcards**: `*` (multiple chars), `?` (single char)
  - Examples: `*Controller`, `Get*`, `Is?Valid`
- **Regex**: When `patternType: "regex"` is specified
  - Uses .NET regex syntax
  - Examples: `"async.*{"`, `"(?<!await ).*Async\\("`

### Statement IDs
- Format: `stmt-123` (ephemeral, session-scoped)
- Generated by `find-statements` tool
- Valid only within current session
- Can be used with `replace-statement` for convenient statement targeting
- Stored in session memory with full syntax node references

### Marker IDs
- Format: `mark-1`, `mark-2`, etc.
- Generated by `mark-statement` tool
- Survive through code edits but not file reloads
- Built on Roslyn's SyntaxAnnotation system for reliable node tracking

## Tool Categories

### 1. Workspace Management

#### `dotnet-load-workspace`
**MCP Description**: "Load a .NET solution or project into the workspace"

**Purpose**: Load a C# project or solution into the workspace for analysis and manipulation.

**⚠️ Important**: Only full (absolute) paths are supported. Relative paths like `./project.csproj` or `../solution.sln` will not work because the server needs to resolve project references and dependencies correctly.

**Input Format**:
```json
{
  "path": "/path/to/project.csproj",  // Required: FULL PATH to .sln or .csproj file (relative paths not supported)
  "workspaceId": "custom-id"          // Optional: auto-generated if not provided
}
```

**Output Format**:
```json
{
  "Id": "TestProject_1b72f2d7",
  "Path": "/path/to/project.csproj",
  "Type": "Project",
  "Status": "Loaded",
  "LoadedAt": "2025-07-29T23:28:01Z",
  "ProjectCount": 1
}
```

**Use Case**: Must be called before any other operations to establish the working context

#### `dotnet-workspace-status`
**MCP Description**: "Get loading progress and workspace info"

**Purpose**: Get detailed status of loaded workspaces including project information.

**Input Format**:
```json
{
  "workspaceId": "specific-id"  // Optional: returns all if not specified
}
```

**Output Format**:
```json
{
  "workspaceCount": 1,
  "totalProjectCount": 3,
  "workspaces": [
    {
      "id": "TestProject_1b72f2d7",
      "path": "/path/to/project.csproj",
      "type": "Project",
      "status": "Loaded",
      "loadedAt": "2025-07-29T23:28:01Z",
      "projectCount": 3,
      "projects": ["Project1", "Project2", "Project3"]
    }
  ]
}
```

**Use Case**: Check what projects are available for analysis, verify load status

#### `dotnet-fsharp-projects`
**MCP Description**: "Get information about F# projects in the workspace (detected but not loaded by MSBuild)"

**Purpose**: List F# projects that were detected but cannot be loaded by MSBuildWorkspace due to F# compiler limitations.

**Input Format**:
```json
{
  "workspaceId": "specific-id",  // Optional: filter by workspace
  "includeLoaded": false         // Optional: include successfully loaded F# projects
}
```

**Output Format**:
```text
F# Projects (Skipped): 2

Project: FSharpLibrary
  Path: /path/to/FSharpLibrary.fsproj
  Workspace: MyProject_a1b2c3d4
  Status: Not Loaded
  Detected: 2025-01-15 10:30:25

Note: F# projects are not fully supported by MSBuildWorkspace.
To work with F# projects, use FSharp.Compiler.Service directly.
```

**Use Case**: Identify F# projects in mixed-language solutions, understand why certain projects aren't loaded

#### `dotnet-get-diagnostics`
**MCP Description**: "Get compilation diagnostics (errors, warnings, info) from the workspace"

**Purpose**: Retrieve compilation errors, warnings, and info messages with precise locations for error resolution.

**Input Format**:
```json
{
  "workspaceId": "TestProject_1b72f2d7",  // Optional: filter by workspace
  "severityFilter": "Error",              // Optional: Error|Warning|Info|Hidden
  "file": "/path/to/file.cs",            // Optional: filter by specific file
  "maxResults": 100                       // Optional: limit results (default: 50)
}
```

**Output Format**:
```json
{
  "diagnostics": [
    {
      "id": "CS0103",
      "severity": "Error", 
      "message": "The name 'undeclaredVariable' does not exist in the current context",
      "location": {
        "file": "/path/test-workspace/Program.cs",
        "line": 14,
        "column": 9
      },
      "category": "Compiler",
      "warningLevel": 0,
      "isEnabledByDefault": true,
      "isSuppressed": false
    }
  ],
  "summary": {
    "totalCount": 4,
    "errorCount": 4,
    "warningCount": 0,
    "infoCount": 0
  }
}
```

**Common Diagnostic IDs**:
- **CS0103**: Undeclared variable/method
- **CS1061**: Missing method on type
- **CS0029**: Type conversion error
- **CS0246**: Missing type/namespace
- **CS0161**: Not all code paths return
- **CS8618**: Non-nullable reference not initialized

**Use Case**: Starting point for diagnostic-driven error resolution, identifying compilation issues before refactoring

#### `dotnet-load-fsharp-project`
**MCP Description**: "Load an F# project using FSharp.Compiler.Service (separate from MSBuild workspaces)"

**Purpose**: Load and analyze F# projects using the F# compiler service directly.

**Input Format**:
```json
{
  "projectPath": "/path/to/project.fsproj"  // Required: path to F# project file
}
```

**Output Format**:
```text
F# Project: FSharpLibrary
Path: /path/to/FSharpLibrary.fsproj
Status: Loaded successfully
Source Files: 5
  - Library.fs
  - Types.fs
  - AsyncExamples.fs
  - PatternMatching.fs
  - Utils.fs
References: 8
```

**Use Case**: Enable F# code analysis when MSBuildWorkspace cannot handle F# projects

#### `dotnet-fsharp-find-symbols`
**MCP Description**: "Find symbols in F# code using FSharpPath queries"

**Purpose**: Search F# code using FSharpPath (XPath-style queries for F# AST).

**Input Format**:
```json
{
  "filePath": "/path/to/file.fs",          // Required: F# source file
  "query": "//function[@recursive]"        // Required: FSharpPath query
}
```

**FSharpPath Query Examples**:
- `//function` - All functions
- `//function[@async]` - Async functions
- `//function[@recursive]` - Recursive functions
- `//type[Union]` - Discriminated unions
- `//type[Record]` - Record types
- `//value[@mutable]` - Mutable values

**Output Format**:
```text
F# Symbols found with query '//function[@recursive]': 3

Symbol: factorial
  Type: Function
  File: Library.fs
  Access: public
  - Recursive

Symbol: quickSort
  Type: Function
  File: Algorithms.fs
  Access: public
  - Recursive
```

**Use Case**: Navigate and analyze F# code structures, find specific F# constructs

### 2. Code Discovery Tools (Read-Only)

#### `dotnet-find-class`
**MCP Description**: "Find classes, interfaces, structs, or enums by name pattern (supports * and ? wildcards)"

**Purpose**: Find type definitions by name pattern using wildcards.

**Input Format**:
```json
{
  "pattern": "*Controller",           // Required: supports * and ? wildcards
  "workspacePath": "/path/to/search"  // Optional: searches all if not specified
}
```

**Output Format**:
```text
Found 3 type(s) matching '*Controller':

1. UserController (class)
   Location: /path/src/UserController.cs:5:1
   Namespace: MyApp.Controllers
   Base: ControllerBase
   Implements: IUserService

2. ProductController (class)
   Location: /path/src/ProductController.cs:8:1
   Namespace: MyApp.Controllers
```

**Pattern Examples**:
- `*Controller` - All controllers
- `I*Service` - All service interfaces
- `Base*` - All base classes
- `User?` - User1, UserA, etc.

**Use Case**: Discover classes matching naming conventions, find all implementations of a pattern

#### `dotnet-find-method`
**MCP Description**: "Find methods by name pattern with optional class pattern filter (supports * and ? wildcards)"

**Purpose**: Find methods by name pattern with optional class filtering.

**Input Format**:
```json
{
  "methodPattern": "Get*",             // Required: method name pattern
  "classPattern": "*Service",         // Optional: filter by class pattern
  "workspacePath": "/path/to/search"  // Optional: searches all if not specified
}
```

**Output Format**:
```text
Found 5 method(s) matching 'Get*':

1. GetUser in UserService
   Location: /path/src/UserService.cs:15:5
   Signature: public Task<User> GetUser(int id)
   Returns: Task<User>
   Parameters: int id

2. GetAllUsers in UserService
   Location: /path/src/UserService.cs:25:5
   Signature: public Task<List<User>> GetAllUsers()
```

**Use Case**: Locate methods for analysis, find all async methods, discover API endpoints

#### `dotnet-find-property`
**MCP Description**: "Find properties and fields by name pattern with optional class pattern filter (supports * and ? wildcards)"

**Purpose**: Find properties and fields by name pattern.

**Input Format**:
```json
{
  "propertyPattern": "Is*",            // Required: property/field name pattern
  "classPattern": "*Model",           // Optional: filter by class pattern
  "workspacePath": "/path/to/search"  // Optional: searches all if not specified
}
```

**Output Format**:
```text
Found 4 properties/fields matching 'Is*':

1. IsActive (property) in UserModel
   Location: /path/src/Models/UserModel.cs:10:5
   Type: bool
   Getter: public
   Setter: public

2. IsDeleted (field) in BaseEntity
   Location: /path/src/Models/BaseEntity.cs:5:5
   Type: bool
   Access: private
```

**Use Case**: Find all boolean flags, discover model properties, locate configuration fields

#### `dotnet-find-namespace`
**Note**: This tool is not currently implemented in the server.

**Purpose**: Find namespaces by pattern.
- **Input**: Name pattern
- **Output**: List of namespaces with member counts
- **Use Case**: Understand code organization

### 3. Relationship Analysis Tools

#### `dotnet-find-method-calls`
**MCP Description**: "Find all methods called by a specific method (call tree analysis)"

**Purpose**: Analyze what methods are called BY a specific method (outgoing calls).

**Input Format**:
```json
{
  "methodName": "ProcessOrder",        // Required: method to analyze
  "className": "OrderService",        // Required: containing class
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Method calls from OrderService.ProcessOrder:

Direct calls (5):
1. ValidateOrder (line 25)
   Target: OrderValidator.ValidateOrder
   Location: /path/src/OrderService.cs:25:13

2. SaveOrder (line 30)
   Target: OrderRepository.SaveOrder
   Location: /path/src/OrderService.cs:30:9
   
3. SendNotification (line 35)
   Target: NotificationService.SendNotification
   Location: /path/src/OrderService.cs:35:9
```

**Use Case**: Understand method dependencies, trace execution flow, identify external dependencies

#### `dotnet-find-method-callers`
**MCP Description**: "Find all methods that call a specific method (caller tree analysis)"

**Purpose**: Find all places that CALL a specific method (incoming calls).

**Input Format**:
```json
{
  "methodName": "SaveOrder",           // Required: method being called
  "className": "OrderRepository",     // Required: containing class
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Methods calling OrderRepository.SaveOrder:

Found 3 caller(s):
1. OrderService.ProcessOrder
   Location: /path/src/OrderService.cs:30:9
   Call: await _repository.SaveOrder(order);
   
2. OrderService.UpdateOrder
   Location: /path/src/OrderService.cs:55:13
   Call: _repository.SaveOrder(updatedOrder);
   
3. OrderImporter.ImportOrders
   Location: /path/src/OrderImporter.cs:120:17
   Call: repo.SaveOrder(importedOrder);
```

**Use Case**: Impact analysis before changes, understand usage patterns, find all consumers

#### `dotnet-find-references`
**MCP Description**: "Find all references to a type, method, property, or field"

**Purpose**: Find all usages of any symbol across the codebase.

**Input Format**:
```json
{
  "symbolName": "User",                // Required: symbol to find
  "symbolType": "type",               // Required: type|method|property|field
  "containerName": "UserService",     // Optional: for methods/properties/fields
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 12 reference(s) to 'User' (type):

1. Variable declaration
   Location: /path/src/UserService.cs:25:9
   Context: User user = await GetUser(id);
   
2. Method parameter
   Location: /path/src/UserValidator.cs:10:30
   Context: public bool ValidateUser(User user)
   
3. Return type
   Location: /path/src/UserRepository.cs:15:12
   Context: public Task<User> FindById(int id)
```

**Use Case**: Find all usages before renaming, understand symbol dependencies, locate all consumers

#### `dotnet-find-implementations`
**MCP Description**: "Find all implementations of an interface or abstract class"

**Purpose**: Discover all concrete implementations of interfaces or abstract classes.

**Input Format**:
```json
{
  "interfaceName": "IUserService",     // Required: interface or abstract class
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 3 implementation(s) of 'IUserService':

1. UserService
   Location: /path/src/Services/UserService.cs:8:1
   Type: class
   Implements: IUserService, IDisposable
   
2. MockUserService
   Location: /path/tests/Mocks/MockUserService.cs:5:1
   Type: class
   Implements: IUserService
   
3. CachedUserService
   Location: /path/src/Services/CachedUserService.cs:10:1
   Type: class
   Implements: IUserService
   Base: UserService
```

**Use Case**: Find all implementations for testing, understand service variations, locate mock implementations

#### `dotnet-find-overrides`
**MCP Description**: "Find all overrides of a virtual or abstract method"

**Purpose**: Find all methods that override a virtual or abstract method.

**Input Format**:
```json
{
  "methodName": "SaveChanges",         // Required: virtual/abstract method
  "className": "BaseRepository",      // Required: declaring class
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 4 override(s) of 'BaseRepository.SaveChanges':

1. UserRepository.SaveChanges
   Location: /path/src/Repositories/UserRepository.cs:45:5
   Signature: public override async Task<int> SaveChanges()
   Adds: Async behavior
   
2. AuditableRepository.SaveChanges
   Location: /path/src/Repositories/AuditableRepository.cs:30:5
   Signature: public override async Task<int> SaveChanges()
   Adds: Audit logging
```

**Use Case**: Understand customization points, track override implementations, ensure consistent behavior

#### `dotnet-find-derived-types`
**MCP Description**: "Find all types that derive from a base class"

**Purpose**: Discover all classes that inherit from a specific base class.

**Input Format**:
```json
{
  "baseClassName": "ControllerBase",   // Required: base class name
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 5 type(s) deriving from 'ControllerBase':

1. UserController
   Location: /path/src/Controllers/UserController.cs:8:1
   Direct parent: ControllerBase
   Implements: IUserController
   
2. ApiControllerBase
   Location: /path/src/Controllers/ApiControllerBase.cs:5:1
   Direct parent: ControllerBase
   Abstract: Yes
   
3. ProductController
   Location: /path/src/Controllers/ProductController.cs:10:1
   Direct parent: ApiControllerBase
   Inheritance chain: ProductController -> ApiControllerBase -> ControllerBase
```

**Use Case**: Map inheritance hierarchies, find all subclasses for refactoring, understand type relationships

### 4. Statement-Level Operations

#### `dotnet-find-statements`
**MCP Description**: "Find statements in code matching a pattern. Returns statement IDs for use with other operations. Uses Roslyn's syntax tree to enumerate all statements."

**Purpose**: Search for statements matching text or regex patterns for analysis or bulk operations.

**Input Format:**
```json
{
  "pattern": "Console.WriteLine",      // Required: text, regex, or RoslynPath pattern
  "patternType": "text",              // Optional: "text" (default), "regex", or "roslynpath"
  "scope": {                          // Optional: limit search scope
    "file": "/path/to/file.cs",
    "className": "UserService",
    "methodName": "ProcessUser"
  },
  "includeNestedStatements": true,    // Optional: include statements in blocks
  "groupRelated": false,              // Optional: group related statements
  "workspacePath": "/path/to/search"  // Optional
}
```

**Pattern Types:**
- **text** (default): Simple text search within statement text
- **regex**: Regular expression pattern matching
- **roslynpath**: XPath-style queries for sophisticated matching

**RoslynPath Examples:**
- `//statement[@contains='TODO']` - Find TODO comments
- `//method[Get*]//statement[@type=ThrowStatement]` - Throws in Get methods
- `//method[@async]//statement[@type=ReturnStatement and not(@contains='await')]` - Non-awaited returns in async methods
- `//foreach//expression[@contains='.First(']` - Potential N+1 query patterns
- `//class[*Service]//statement[@type=IfStatement and @contains='== null']` - Null checks in service classes

**Output Format**:
```text
Found 3 statement(s) matching 'Console.WriteLine':

1. Statement ID: stmt-1
   Location: /path/src/Program.cs:10:9
   Context: Method 'Main' in class 'Program'
   Statement: Console.WriteLine("Starting application...");
   
2. Statement ID: stmt-2
   Location: /path/src/UserService.cs:25:13
   Context: Method 'LogUser' in class 'UserService'
   Statement: Console.WriteLine($"User {user.Name} logged in");
```

**Pattern Examples**:
- `"Console.WriteLine"` - Find all console output
- `"new .*Exception"` (regex) - Find exception creation
- `"await .*Async\\("` (regex) - Find async calls
- `"if \\(.*== null\\)"` (regex) - Find null checks

**Use Case**: Find patterns for refactoring, locate logging statements, identify async patterns

#### `dotnet-replace-statement`
**MCP Description**: "Replace a statement with new code. The statement is identified by its location from find-statements. Preserves indentation and formatting context."

**Purpose**: Replace an entire statement at a specific location.

**Input Format**:
```json
{
  "location": {                       // Required: exact location
    "file": "/path/to/file.cs",
    "line": 25,
    "column": 9
  },
  "newStatement": "logger.LogInfo(\"User logged in\");",  // Required
  "preserveComments": true,           // Optional: keep existing comments
  "workspacePath": "/path/to/search"  // Optional
}
```

**Alternative Input** (with statementId from find-statements):
```json
{
  "statementId": "stmt-123",           // From find-statements
  "newStatement": "logger.LogInfo(\"User logged in\");",
  "preserveComments": true
}
```

**Output Format**:
```text
Statement replaced successfully in /path/to/file.cs

Original: Console.WriteLine("User logged in");
New: logger.LogInfo("User logged in");

Preview:
Before:
  23:     public void LogUser(User user)
  24:     {
  25:         Console.WriteLine("User logged in");
  26:         ProcessUser(user);

After:
  23:     public void LogUser(User user)
  24:     {
  25:         logger.LogInfo("User logged in");
  26:         ProcessUser(user);
```

**Use Case**: Replace logging methods, update API calls, modernize syntax

#### `dotnet-insert-statement`
**MCP Description**: "Insert a new statement before or after an existing statement. The reference statement is identified by its location from find-statements. Preserves indentation and formatting context."

**Purpose**: Add new statements relative to existing code.

**Input Format**:
```json
{
  "position": "before",                // Required: "before" or "after"
  "location": {                       // Required: reference location
    "file": "/path/to/file.cs",
    "line": 30,
    "column": 9
  },
  "statement": "ArgumentNullException.ThrowIfNull(user);",  // Required
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Statement inserted successfully in /path/to/file.cs

Inserted before line 30:
ArgumentNullException.ThrowIfNull(user);

Preview:
Before:
  28:     public void ProcessUser(User user)
  29:     {
  30:         var result = ValidateUser(user);
  31:         SaveUser(user);

After:
  28:     public void ProcessUser(User user)
  29:     {
  30:         ArgumentNullException.ThrowIfNull(user);
  31:         var result = ValidateUser(user);
  32:         SaveUser(user);
```

**Use Case**: Add validation, insert logging, add null checks, insert using statements

#### `dotnet-remove-statement`
**MCP Description**: "Remove a statement from the code. The statement is identified by its location from find-statements. Can preserve comments attached to the statement."

**Purpose**: Delete statements while optionally preserving their comments.

**Input Format**:
```json
{
  "location": {                       // Required: statement location
    "file": "/path/to/file.cs",
    "line": 45,
    "column": 9
  },
  "preserveComments": true,           // Optional: default true
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Statement removed successfully from /path/to/file.cs

Removed: Console.WriteLine("Debug info");
Preserved comment: // TODO: Replace with proper logging

Preview:
Before:
  43:     public void DebugMethod()
  44:     {
  45:         // TODO: Replace with proper logging
  46:         Console.WriteLine("Debug info");
  47:         ProcessData();

After:
  43:     public void DebugMethod()
  44:     {
  45:         // TODO: Replace with proper logging
  46:         ProcessData();
```

**Use Case**: Remove debug code, clean up obsolete statements, remove commented-out code

### 5. Ephemeral Marker System

#### `dotnet-mark-statement`
**MCP Description**: "Mark a statement with an ephemeral marker for later reference. Markers are session-scoped and not persisted."

**Purpose**: Tag statements with temporary identifiers that survive through code edits.

**Input Format**:
```json
{
  "location": {                       // Required: statement location
    "file": "/path/to/file.cs",
    "line": 25,
    "column": 9
  },
  "label": "First output",            // Optional: descriptive label
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Statement marked successfully
Marker ID: mark-1
Label: First output
Statement: Console.WriteLine("Hello, World!");
Location: /path/to/file.cs:25:9
Context: Program.Main
```

**Use Case**: Track statements through multi-step refactoring, maintain references during transformations

#### `dotnet-find-marked-statements`
**MCP Description**: "Find all or specific marked statements. Returns current locations even if code has been edited."

**Purpose**: Locate previously marked statements, even after code modifications.

**Input Format**:
```json
{
  "markerId": "mark-1",                // Optional: specific marker
  "file": "/path/to/file.cs",        // Optional: filter by file
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Found 3 marked statement(s)
Total markers in session: 3

Marker ID: mark-1
Label: First output
Location: /path/to/file.cs:25:9
Context: Method: Main
Statement: Console.WriteLine("Hello, World!");

Marker ID: mark-2
Label: Result output
Location: /path/to/file.cs:30:9
Context: Method: Main
Statement: Console.WriteLine($"Result: {result}");
```

**Use Case**: Find marked statements after edits, track multiple related statements

#### `dotnet-unmark-statement`
**MCP Description**: "Remove a specific marker by its ID."

**Purpose**: Clean up individual markers when no longer needed.

**Input Format**:
```json
{
  "markerId": "mark-2",                // Required: marker to remove
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Marker 'mark-2' removed successfully
Remaining markers: 2
```

**Use Case**: Remove completed markers, clean up after specific operations

#### `dotnet-clear-markers`
**MCP Description**: "Clear all markers in the current session."

**Purpose**: Reset all markers when starting new operations.

**Input Format**:
```json
{
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```text
Cleared 3 marker(s)
```

**Use Case**: Reset marker state, clean up after complex refactoring

#### `dotnet-get-statement-context`
**MCP Description**: "Get comprehensive semantic context for a statement including symbols, types, diagnostics, and basic data flow"

**Purpose**: Provides deep semantic information about a statement for AI agents to understand code context hierarchically.

**Input Format**:
```json
{
  "statementId": "stmt-abc123",       // Option 1: Use statement ID from find-statements
  
  // Option 2: Use direct location
  "file": "/path/to/file.cs",         // File path
  "line": 15,                         // Line number (1-based)
  "column": 9,                        // Column number (1-based)
  
  "workspacePath": "/path/to/search"  // Optional
}
```

**Output Format**:
```json
{
  "statement": {
    "id": "stmt-abc123",
    "code": "var user = await GetUserAsync(userId);",
    "kind": "LocalDeclarationStatement",
    "location": {
      "file": "/path/to/file.cs",
      "line": 15,
      "column": 9,
      "endLine": 15,
      "endColumn": 47
    }
  },
  "semanticInfo": {
    "symbols": [
      {
        "name": "user",
        "kind": "Local",
        "type": "User",
        "isDeclared": true,
        "isImplicitlyTyped": true
      },
      {
        "name": "GetUserAsync",
        "kind": "Method",
        "type": "Method",
        "containingType": "UserService",
        "returnType": "Task<User>",
        "parameters": [
          { "name": "userId", "type": "int" }
        ],
        "declarationLocation": {
          "file": "/path/src/UserService.cs",
          "line": 42,
          "column": 12
        }
      }
    ],
    "typeInfo": {
      "expressionType": "Task<User>",
      "convertedType": "Task<User>",
      "isImplicitConversion": false
    },
    "dataFlow": {
      "variablesRead": ["userId"],
      "variablesDeclared": ["user"],
      "variablesWritten": ["user"]
    }
  },
  "context": {
    "enclosingSymbol": {
      "name": "ProcessUserRequest",
      "kind": "Method",
      "containingType": "UserController"
    },
    "enclosingBlock": {
      "kind": "Block",
      "statementCount": 5,
      "currentIndex": 2
    },
    "availableSymbols": [
      { "name": "userId", "kind": "Parameter", "type": "int" },
      { "name": "_logger", "kind": "Field", "type": "ILogger" }
    ],
    "usings": [
      "System",
      "System.Threading.Tasks",
      "MyApp.Models"
    ]
  },
  "diagnostics": [],
  "suggestions": {
    "canExtractMethod": true,
    "canInlineVariable": false,
    "possibleRefactorings": [
      "Extract Method",
      "Add Null Check"
    ]
  }
}
```

**Use Case**: Hierarchical context walking for AI agents, semantic-aware code modification, diagnostic-driven fixes

#### `dotnet-get-data-flow`
**MCP Description**: "Get comprehensive data flow analysis for a code region showing variable usage, dependencies, and control flow"

**Purpose**: Provides deep data flow analysis to understand how variables flow through code, detect dependencies, and identify potential issues.

**Input Format**:
```json
{
  "file": "/path/to/file.cs",              // Required: file to analyze
  "startLine": 10,                         // Required: start line (1-based)
  "startColumn": 5,                        // Required: start column (1-based)
  "endLine": 20,                           // Required: end line (1-based)
  "endColumn": 30,                         // Required: end column (1-based)
  "includeControlFlow": true,              // Optional: include control flow analysis (default: true)
  "workspacePath": "/path/to/workspace"    // Optional
}
```

**Output Format**:
```json
{
  "region": {
    "file": "/path/to/file.cs",
    "startLine": 10,
    "startColumn": 5,
    "endLine": 20,
    "endColumn": 30,
    "code": "int sum = x + y;\nint product = x * y;\nreturn sum + product;"
  },
  "dataFlow": {
    "dataFlowsIn": ["x", "y"],              // Variables that flow into the region
    "dataFlowsOut": ["result"],             // Variables that flow out of the region
    "alwaysAssigned": ["sum", "product"],   // Variables always assigned
    "readInside": ["x", "y", "sum", "product"],
    "writtenInside": ["sum", "product", "result"],
    "readOutside": [],
    "writtenOutside": ["logger"],
    "captured": ["localVar"],               // Variables captured by closures
    "capturedInside": [],
    "unsafeAddressTaken": []
  },
  "controlFlow": {
    "alwaysReturns": true,
    "endPointIsReachable": false,
    "startPointIsReachable": true,
    "returnStatements": 1,
    "hasYieldStatements": false,
    "exitPoints": ["Return", "Throw"]
  },
  "variableFlows": [
    {
      "name": "sum",
      "type": "int",
      "declaredAt": "10:9",
      "readLocations": ["12:20", "12:35"],
      "writeLocations": ["10:9"],
      "isDefinitelyAssignedOnEntry": false,
      "isDefinitelyAssignedOnExit": true,
      "mayBeUnassigned": false
    }
  ],
  "dependencies": [
    {
      "variable": "result",
      "dependsOn": ["sum", "product"],
      "reason": "Initialization"
    }
  ],
  "warnings": [
    {
      "type": "UnusedVariable",
      "message": "Variable 'temp' is declared but never used",
      "variable": "temp",
      "location": "15:13"
    },
    {
      "type": "UninitializedRead",
      "message": "Variable 'x' may be used before being initialized",
      "variable": "x",
      "location": "16:25"
    }
  ]
}
```

**Use Case**: Complex refactoring planning, dead code detection, dependency analysis, null safety verification

### 6. Code Modification Tools

#### `dotnet-rename-symbol`
**MCP Description**: "Rename a symbol (type, method, property, field) and update all references"

**Purpose**: Safely rename any symbol across the entire codebase with all references updated.

**Input Format**:
```json
{
  "oldName": "GetUser",                // Required: current name
  "newName": "GetUserById",            // Required: new name
  "symbolType": "method",              // Required: type|method|property|field
  "containerName": "UserService",     // Optional: for methods/properties/fields
  "workspacePath": "/path/to/apply",  // Optional
  "preview": false                    // Optional: preview without applying
}
```

**Output Format**:
```text
Renamed 'GetUser' to 'GetUserById' in 8 location(s):

1. Method definition
   Location: /path/src/UserService.cs:15:12
   Change: public async Task<User> GetUser(int id)
        -> public async Task<User> GetUserById(int id)

2. Method call
   Location: /path/src/UserController.cs:25:20
   Change: var user = await _service.GetUser(userId);
        -> var user = await _service.GetUserById(userId);

3. Interface definition
   Location: /path/src/IUserService.cs:8:5
   Change: Task<User> GetUser(int id);
        -> Task<User> GetUserById(int id);
```

**Use Case**: Refactor method names, update property names, rename types consistently

#### `dotnet-edit-code`
**MCP Description**: "Perform surgical code edits using Roslyn. Operations: add-method, add-property, make-async, add-parameter, wrap-try-catch"

**Purpose**: Perform complex structural edits beyond simple text replacement.

**Input Format**:
```json
{
  "file": "/path/to/file.cs",         // Required: file to edit
  "operation": "add-method",          // Required: operation type
  "className": "UserService",        // Required: target class
  "methodName": "ValidateUser",      // For method operations
  "code": "method code here",        // For add operations
  "parameters": {                    // Operation-specific parameters
    "parameterName": "cancellationToken",
    "parameterType": "CancellationToken",
    "defaultValue": "default"
  },
  "preview": false                   // Optional: preview only
}
```

**Operations**:

1. **add-method**: Add a new method to a class
   ```json
   {
     "operation": "add-method",
     "code": "public async Task<bool> ValidateUser(User user)\n{\n    return user != null && user.IsActive;\n}"
   }
   ```

2. **add-property**: Add a new property to a class
   ```json
   {
     "operation": "add-property",
     "code": "public DateTime LastModified { get; set; }"
   }
   ```

3. **make-async**: Convert method to async
   ```json
   {
     "operation": "make-async",
     "methodName": "ProcessData"
   }
   ```

4. **add-parameter**: Add parameter to method
   ```json
   {
     "operation": "add-parameter",
     "methodName": "ProcessUser",
     "parameters": {
       "parameterName": "options",
       "parameterType": "ProcessOptions",
       "defaultValue": "null"
     }
   }
   ```

5. **wrap-try-catch**: Wrap method body in try-catch
   ```json
   {
     "operation": "wrap-try-catch",
     "methodName": "SaveData",
     "parameters": {
       "catchType": "Exception",
       "logError": true
     }
   }
   ```

**Output Format**:
```text
Operation 'add-method' completed successfully

Added method 'ValidateUser' to class 'UserService'
Location: /path/src/UserService.cs:45:5

Preview:
  43:     }
  44:     
  45:     public async Task<bool> ValidateUser(User user)
  46:     {
  47:         return user != null && user.IsActive;
  48:     }
  49: }
```

**Use Case**: Add methods/properties, convert to async, add parameters, add error handling

#### `dotnet-fix-pattern`
**MCP Description**: "Find code matching a pattern and transform it to a new pattern"

**Purpose**: Apply pattern-based transformations across the codebase.

**Input Format**:
```json
{
  "findPattern": "Console.WriteLine",  // Required: pattern to find
  "replacePattern": "_logger.LogInfo", // Required: replacement pattern
  "patternType": "method-call",       // Required: pattern type
  "workspacePath": "/path/to/apply",  // Optional
  "preview": true                     // Optional: preview changes
}
```

**Pattern Types**:
- `method-call`: Transform method invocations
- `property-access`: Transform property access patterns
- `async-usage`: Add/remove async/await
- `null-check`: Transform null checking patterns
- `string-format`: Update string formatting

**Output Format**:
```text
Found 5 instance(s) of pattern 'Console.WriteLine':

1. /path/src/Program.cs:10:9
   Before: Console.WriteLine("Starting...");
   After:  _logger.LogInfo("Starting...");

2. /path/src/UserService.cs:25:13
   Before: Console.WriteLine($"User {id} found");
   After:  _logger.LogInfo($"User {id} found");

Apply changes? (preview mode)
```

**Use Case**: Migrate logging frameworks, update API usage patterns, modernize code patterns

## Usage Patterns

### 1. Discovery → Analysis → Modification
```
1. find-class "Repository" → Locate target classes
2. find-method-calls → Understand dependencies  
3. mark-statement → Mark areas of interest
4. replace-statement → Make modifications
```

### 2. Impact Analysis Before Changes
```
1. find-references → See all usages
2. find-overrides → Check inheritance impact
3. rename-symbol → Safe rename with preview
```

### 3. Pattern-Based Refactoring
```
1. find-statements "Console.WriteLine" → Find all logging
2. mark-statement (multiple) → Mark statements to change
3. Loop: replace-statement → Update each to use logger
4. clear-markers → Clean up
```

### 4. Multi-Step Refactoring with Markers
```
1. find-statements "async.*{" → Find async methods
2. mark-statement → Mark each method
3. find-statements "(?<!await ).*Async\\(" → Find non-awaited async calls
4. Loop through marked methods:
   - find-marked-statements → Get method
   - insert-statement "await" → Add await keyword
5. clear-markers → Clean up
```

### 5. Diagnostic-Driven Error Resolution with Context Walking

#### Roslyn Node Identification Integration

**Built-in Roslyn Tracking Mechanisms:**
- **TextSpan**: Every diagnostic provides precise line/column location via TextSpan
- **SyntaxAnnotation**: Roslyn's persistent node tagging system (used by our markers)
- **TrackNodes**: Editor integration for maintaining references through edits

**Diagnostic → Marker → Fix Workflow:**
```
1. dotnet-get-diagnostics → Provides TextSpan location (line:column)
2. mark-statement → Converts TextSpan to SyntaxAnnotation marker (edit-resilient)
3. Apply fixes using marker references (not line numbers)
4. Markers survive code edits during multi-step resolution
```

**Key Insight**: Our "ephemeral" markers are actually built on Roslyn's robust SyntaxAnnotation system, providing stable references that survive syntax tree transformations.

**Hierarchical Context Analysis Pattern:**
```
1. dotnet-get-diagnostics → Get compilation errors with precise locations
2. mark-statement → Mark the error location for stable reference
3. Context Walking (expand outward as needed):
   a. Error statement: //statement[@markerId='mark-1']
   b. Enclosing block: //statement[@markerId='mark-1']/ancestor::*[1] 
   c. Sibling statements: //statement[@markerId='mark-1']/ancestor::*[1]/../*
   d. Parent method: //statement[@markerId='mark-1']/ancestor::method[1]
   e. Parent class: //statement[@markerId='mark-1']/ancestor::class[1]
4. mark-statement → Mark relevant context levels
5. Targeted resolution using context + error type
6. clear-markers → Clean up when done
```

**Error-Specific Resolution Workflows:**

**CS0103 (Undeclared Variable):**
```
1. Mark error location → mark-1
2. Find enclosing method context → mark-2  
3. Check variable declarations in scope via siblings
4. Resolution options:
   - replace-statement → Fix assignment (int variable = value)
   - remove-statement → Remove invalid assignment
   - insert-statement → Add variable declaration above
```

**CS1061 (Missing Method):**
```
1. Mark error location → mark-1
2. Find object type via context analysis
3. Resolution options:
   - replace-statement → Fix method name (find similar methods)
   - remove-statement → Remove invalid call
   - find-symbols + insert-statement → Add missing method to target class
```

**CS0029 (Type Mismatch):**
```
1. Mark error location → mark-1
2. Analyze expected vs actual types from context
3. Resolution options:
   - replace-statement → Fix type (string x = "value" or int x = 42)
   - insert-statement → Add type conversion
   - replace-statement → Change variable type declaration
```

**CS0246 (Missing Type):**
```
1. Mark error location → mark-1
2. Check file-level using statements and available types
3. Resolution options:
   - insert-statement → Add using statement at file top
   - replace-statement → Use existing type (object, var, etc.)
   - insert-statement → Add missing class/interface definition
```

**Example: Complete Error Resolution Workflow**
```
# Diagnostic shows: CS0103 at Program.cs:14:9 - 'undeclaredVariable' does not exist

1. mark-statement(location: line 14, col 9) → mark-1 "error_location"

2. Context walking with markers:
   - mark-statement(roslynPath: "//statement[@markerId='mark-1']/ancestor::method[1]") → mark-2 "method_context"
   - find-statements(pattern: "//statement[@markerId='mark-2']//statement[@type='VariableDeclaration']") → See existing variables
   - find-statements(pattern: "//statement[@markerId='mark-1']/following-sibling::statement[1]") → Check next statement

3. Analysis reveals: undeclaredVariable = subtotal + tax; followed by order.Total = total;
   Context suggests: should be "var total = subtotal + tax;"

4. replace-statement(markerId: "mark-1", newStatement: "var total = subtotal + tax;")

5. Verification: dotnet-get-diagnostics → Confirm CS0103 resolved

6. clear-markers → Clean up session
```

## Best Practices

1. **Always Load First**: Call `load-workspace` before any operations
2. **Start with Diagnostics**: Use `dotnet-get-diagnostics` to identify compilation errors before manual analysis
3. **Mark Before Modify**: Use `mark-statement` to create stable references that survive edits
4. **Context Walking**: Expand analysis hierarchically - statement → enclosing → siblings → method → class
5. **Verify Fixes**: Re-run `dotnet-get-diagnostics` after changes to confirm resolution
6. **Clean Up Markers**: Use `clear-markers` after complex operations to avoid session bloat
7. **Preview Changes**: Most modification tools show previews - review them carefully
8. **Combine Tools**: Use discovery tools to find targets, then modification tools to change them
9. **RoslynPath for Stability**: Prefer RoslynPath queries over text patterns for precise syntax tree navigation

## Tool Composition Examples

### Adding Logging to All Public Methods
```
1. find-method → Find all public methods
2. For each method:
   - mark-statement → Mark method start
   - insert-statement → Add entry logging
   - find-statements "return" → Find return statements
   - insert-statement → Add exit logging before returns
```

### Converting Synchronous to Async
```
1. find-method-calls → Find methods calling async operations
2. mark-statement → Mark these methods
3. For each marked method:
   - edit-code → Add async keyword to signature
   - edit-code → Change return type to Task<T>
   - find-method-callers → Find callers
   - Loop: Add await to call sites
```

### Extracting Magic Numbers
```
1. find-statements "[0-9]+" → Find numeric literals
2. mark-statement → Mark each occurrence
3. insert-statement → Add constants at class level
4. replace-statement → Replace literals with constants
5. clear-markers → Clean up
```

## Tool Implementation Status

### Fully Implemented (25 tools)
- ✅ Workspace: load-workspace, workspace-status, get-diagnostics
- ✅ Discovery: find-class, find-method, find-property
- ✅ Relationships: find-method-calls, find-method-callers, find-references, find-implementations, find-overrides, find-derived-types
- ✅ Statements: find-statements, replace-statement, insert-statement, remove-statement
- ✅ Markers: mark-statement, find-marked-statements, unmark-statement, clear-markers
- ✅ Refactoring: rename-symbol, edit-code, fix-pattern

### Not Implemented (3 tools)
- ❌ analyze-syntax: Syntax tree analysis (placeholder)
- ❌ get-symbols: Symbol retrieval at position (placeholder)
- ❌ find-namespace: Namespace discovery (not in tool list)

## Important Notes

### General Guidelines
- All find operations are read-only and don't modify code
- File paths must be absolute paths (not relative)
- Most tools support `preview` mode to review changes before applying
- Pattern matching uses .NET regex syntax when `patternType: "regex"`
- Workspace must be loaded before any analysis/modification operations

### Statement Operations
- Statement IDs (stmt-123) are ephemeral and session-scoped
- Locations use 1-based line and column numbers
- Statement operations preserve indentation automatically
- Comments can be preserved when removing statements

### Marker System
- Markers are session-scoped and not persisted to disk
- Markers survive through normal code edits
- Markers are lost when files are reloaded from disk
- Maximum 100 markers per session
- Markers use Roslyn's SyntaxAnnotation internally

### Symbol Operations
- Symbol types: `type`, `method`, `property`, `field`
- Container name required for methods/properties/fields
- Rename operations update all references across workspace
- Preview mode recommended for large-scale changes

## Error Handling

All tools return structured error responses:
```text
Error: <error message>
```

Common errors:
- "Workspace not loaded" - Call load-workspace first
- "Symbol not found" - Check symbol name and type
- "Location not found" - Verify file path and line/column
- "Pattern syntax error" - Check regex syntax for regex patterns
- "Marker not found" - Marker ID doesn't exist

## Performance Considerations

1. **Large Codebases**: Find operations may take time on large solutions
2. **Pattern Complexity**: Complex regex patterns impact performance
3. **Workspace Loading**: Initial load can be slow for large solutions
4. **Symbol Resolution**: Cross-assembly references may be slower
5. **Batch Operations**: Use markers to batch related changes efficiently